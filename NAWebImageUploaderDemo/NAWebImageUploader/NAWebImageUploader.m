//
//  NAWebImageUploader.m
//  NAWebImageUploaderDemo
//
//  Created by zuopengl on 3/14/16.
//  Copyright Â© 2016 Apple. All rights reserved.
//

#import "NAWebImageUploader.h"
#import "NAWebImageUploaderOperation.h"


NSString *const NAWebImageErrorDomain = @"NAWebImageUploader.ErrorDomain";

NSString *const NAWebImageUploadProgressKey  = @"NAWebImageUploadProgressKey";
NSString *const NAWebImageUploadCompletedKey = @"NAWebImageUploadCompletedKey";

inline NSError *NADefaultErrorForDescriptionValue(NSString *value) {
    return value ? [NSError errorWithDomain:NAWebImageErrorDomain code:0 userInfo:@{NSLocalizedDescriptionKey:value}] : nil;
}

@interface NAWebImageUploader ()
/**
 *  Operation queue for image Uploader
 */
@property (nonatomic, strong) NSOperationQueue *uploaderQueue;

@property (nonatomic, strong) NSOperation *lastOperation;

/**
 *  Key: is unique generated by UIImage and url
 */
@property (nonatomic, strong) NSMutableDictionary *callbacksForImages;

@property (nonatomic, strong) dispatch_queue_t barrier_queue;
@end

@implementation NAWebImageUploader

+ (instancetype)sharedUploader {
    static dispatch_once_t onceToken;
    static id inst = nil;
    dispatch_once(&onceToken, ^{
        inst = [self new];
    });
    return inst;
}


- (instancetype)init {
    if ((self = [super init])) {
        _order = kNAWebImageUploaderOrderForFIFO;
        _options = kNAWebImageUploaderNone;
        
        _callbacksForImages = [NSMutableDictionary new];
        _uploaderQueue = [[NSOperationQueue alloc] init];
        
        _barrier_queue = dispatch_queue_create("uploader.queue.na", DISPATCH_QUEUE_CONCURRENT);
    }
    return self;
}


- (void)dealloc {
    [_uploaderQueue cancelAllOperations];
}


- (id<NAWebImageOperationDelegate>)uploadImage:(UIImage *)image toURL:(NSURL *)url options:(NAWebImageUploaderOptions)options progress:(NAWebImageUploadProgressBlock)progressBlock completion:(NAWebImageUploadCompletedBlock)completedBlock {
    if (!completedBlock) {
        @throw @"CompletedBlock can not be nil";
        return nil;
    }
    
    if (!image) {
        safe_dispatch_async_main(completedBlock, image, nil, nil, NADefaultErrorForDescriptionValue(@"Uploaded image is nil"));
        return nil;
    }
    
    if ([url isKindOfClass:[NSString class]]) {
        url = [NSURL URLWithString:(NSString *)url];
    }
    
    if (!url || ![url isKindOfClass:[NSURL class]]) {
        safe_dispatch_async_main(completedBlock, image, nil, nil, NADefaultErrorForDescriptionValue(@"Requested URL is not valid"));
        return nil;
    }
    
    __block NAWebImageUploaderOperation *operation = nil;
    __weak typeof(self) weakSelf = self;
    [self setCallbacksForImage:image andURL:url progress:progressBlock completion:completedBlock create:^{
        __strong typeof(weakSelf) strongSelf = weakSelf;
        
        // Init operation property
        NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:0 timeoutInterval:15.f];
        
        
        // Create operation
        operation = [[NAWebImageUploaderOperation alloc] initWithRequest:request options:options progress:^(NSInteger countOfOneSend, NSInteger countOfSend, NSInteger countOfExpectedToSent) {
            __strong typeof(weakSelf) strongSelf2 = weakSelf;
            if (!strongSelf2) return ;
            
            NSArray *callbacks = [strongSelf2.callbacksForImages objectForKey:[self uniquedKeyFromImage:image andURL:url]];
            for (NSDictionary *dic in callbacks) {
                NAWebImageUploadProgressBlock imageUploadProgress = [dic[NAWebImageUploadProgressKey] copy];
                safe_block(imageUploadProgress, countOfOneSend, countOfSend, countOfExpectedToSent);
            }
        } completed:^(UIImage *originalImage, NAWebImageUploaderOperation *operation, id responseObject, NSError *error) {
            __strong typeof(weakSelf) strongSelf2 = weakSelf;
            if (!strongSelf2) return ;
            
            __block NSArray *callbacks = nil;
            dispatch_barrier_sync(strongSelf2.barrier_queue, ^{
               callbacks = [[strongSelf2.callbacksForImages objectForKey:[self uniquedKeyFromImage:image andURL:url]] copy];
            });
            for (NSDictionary *dic in callbacks) {
                NAWebImageUploadCompletedBlock imageUploadCompleted = [dic[NAWebImageUploadProgressKey] copy];
                safe_block(imageUploadCompleted, originalImage, operation, responseObject, error);
            }
            
            dispatch_barrier_sync(strongSelf2.barrier_queue, ^{
                [strongSelf2.callbacksForImages removeObjectForKey:[self uniquedKeyFromImage:image andURL:url]];
            });
        } cancelled:^{
            __strong typeof(weakSelf) strongSelf2 = weakSelf;
            if (!strongSelf2) return ;
            
            dispatch_barrier_sync(strongSelf2.barrier_queue, ^{
                [strongSelf2.callbacksForImages removeObjectForKey:[self uniquedKeyFromImage:image andURL:url]];
            });
        }];
        
        [strongSelf.uploaderQueue addOperation:operation];
        if (strongSelf.order == kNAWebImageUploaderOrderForLIFO) {
            [strongSelf.lastOperation addDependency:operation];
            strongSelf.lastOperation = operation;
        }
    }];
    
    return operation;
}


- (void)setCallbacksForImage:(UIImage *)image andURL:(NSURL *)url progress:(NAWebImageUploadProgressBlock)progressBlock completion:(NAWebImageUploadCompletedBlock)completedBlock create:(NAWebImageNoParamBlock)createBlock {
    dispatch_barrier_sync(self.barrier_queue, ^{
        NSString *uniquedKey = [self uniquedKeyFromImage:image andURL:url];
        BOOL isFirst = NO;
        if (!self.callbacksForImages[uniquedKey]) {
            isFirst = YES;
            self.callbacksForImages[uniquedKey] = [NSMutableArray new];
        }
        
        NSMutableArray *callbacksForImage = self.callbacksForImages[uniquedKey];
        NSMutableDictionary *callbacks = [NSMutableDictionary new];
        if (progressBlock) {
            callbacks[NAWebImageUploadProgressKey] = [progressBlock copy];
        }
        if (completedBlock) {
            callbacks[NAWebImageUploadCompletedKey] = [completedBlock copy];
        }
        [callbacksForImage addObject:callbacks];
        
        if (isFirst) {
            safe_block(createBlock);
        }
    });
}


- (NSString *)uniquedKeyFromImage:(UIImage *)image andURL:(NSURL *)url {
    return url.absoluteString;
}


- (void)cancelAll {
    [self.uploaderQueue cancelAllOperations];
}

#pragma mark - property

- (void)setCountOfMaxConcurrent:(NSUInteger)countOfMaxConcurrent {
    self.uploaderQueue.maxConcurrentOperationCount = countOfMaxConcurrent;
}

- (NSUInteger)countOfMaxConcurrent {
    return [self.uploaderQueue maxConcurrentOperationCount];
}

- (NSUInteger)countOfCurrentConcurrent {
    return [self.uploaderQueue operationCount];
}

@end
